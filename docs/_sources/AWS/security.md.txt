# セキュリティ
## IAMとSTS
AWSサービスの認証認可についてはほぼIAMが管理している

### 基本的な用語

- ルートユーザー  
アカウント作成時に作られるすべての権限を持つユーザーで基本的には利用しない
- IAMユーザー  
IAMで作成するユーザーで個人や役割に応じた権限を付与したユーザーを作成する
- ロール   
特定の個人ではなく役割に相当する概念で、役割を持つ人にまとめて付与できる
- プリンシパル  
AWSリソースに対して、アクションをリクエストする人
- ポリシー  
アクセス許可の具体的な定義

#### ポリシー
ポリシーにはユーザーやグループに付与する`アイデンティティベース`とAWSのサービス側に付与する`リソースベース`が存在する。
アクセス可否は２つのポリシーの組み合わせで決まり、どちらかに明示的な拒否があると実行できない。

### IAM RoleとAssumeRole
[AssumeRoleの解説](https://dev.classmethod.jp/articles/iam-role-and-assumerole/)

IAM Roleは「API権限を委譲する」機能である。

これを実現する機能としてstsを利用したAssumeRole がある。
AssumeRoleとは、stsに信頼できるリクエスト元を定義しておいて、信頼できることを確認できれば、一時的にRoleを与えるというイメージ。

IAMポリシーを作成する際には、信頼できるプリンシパルを定義する`信頼ポリシー`とどのサービスにアクセスできるかの`アクセスポリシー`を定義する。
信頼ポリシーで設定されているプリンシパルがAssumeRoleAPIを実行することで一時的に認証情報が作成され、アクセスポリシーに定義されたサービスを利用できるようになる。


#### リクエスト元を信頼する（アクセスポリシー）
アクセスポリシーで以下のような定義を記述しておく  
principalの部分が信頼できるリクエスト元を定義する部分で、色々な設定が可能
```
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "",
      "Effect": "Allow",
      "Principal": {
        "AWS": [ "123456789012" ] // ← AWSアカウントを信頼
        "Service": [ "ec2.amazonaws.com" ] // ← EC2サービスを信頼
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```


#### クロスアカウント
AssumeRoleを利用することで異なるアカウントのリソースにアクセスする、クロスアカウント設定ができる。

例えばユーザーAがユーザーBのアカウントのS3にアクセスしたい場合は以下の手順を踏む

1. ユーザーBでロールBを作成
2. ロールBのアクセスポリシーでユーザーAのアカウントをPrincipalとして設定
3. ロールBでS3のアクセス許可を設定
4. ユーザーAでロールAを作成
5. ロールAでロールBへのAssumeRoleを設定


## KMS(Key-Management-Service)
データを暗号化するための鍵を管理するサービス

### エンベロープ暗号化
KMSのAPI公開されている直接の暗号化はサイズ制限などがあるので、エンベロープ暗号化を利用する。
通信に流れるのは暗号化されたテキストと暗号化された鍵
暗号化された鍵はKMSにアクセスできないと複合化できないので、そこで安全性を担保しているっぽい。（両方盗まれても鍵を複合化できない）

1. エンドポイントにGenerateDataKey（CMK）を指定
2. プレーンデータキーと暗号化データキーが返却される
3. プレーンデータキーでテキストを暗号化。プレーンデータキーは捨てる
4. 暗号化キーと暗号化テキストを送付
5. 受信者は暗号化キーをエンドポイントに送付するとプレーンデータキーが返却される
6. 暗号化テキストをプレーンデータキーで復号化する


### 主なユースケース
- SSE(Server Side Encryption)
  - SSE-S3  
  S3で管理する鍵で暗号化する（かなりシンプル
  - SSE-C
  S3へのファイルアップロードで、クライアントで準備した鍵で暗号化する
  - SSE-KMS  
  KMSで管理する鍵で暗号化する。監査ログなどを吐くことができる
- CSE(Client Side Encryption)
  - CSE-KMS  
  KMSで管理しているキーを利用して、クライアントサイドで暗号化を実施する
  - CSE-C  
  ユーザー側で用意したキーを利用して、クライアントサイドで暗号化を実施する


## Cognito
Web-AppやMobile-Appに対してAPIベースで認証機能を提供するサービス
### ユーザープール
ユーザーDBに相当するが、AWSがマネージドで管理してくれる。

#### ユースケース
ざっくり分けると３つのユースケースに分類可能。Appへの認証、IDプールと連携してAWSサービスへのアクセス、CognitoからLambdaのキック。
- EC2やECS常に配置したWeb-AppやMobile-Appの認証：アプリケーションへの認証をする
- API GWやALBからのオーソライザ：Tokenの認証をしてIDプールと連携して他のサービスと連携する
- Lambdaを使ったオーソライザ：CognitoがLambdaを使って、サインインのワークフロをカスタマイズする

#### 具体的な利用方法
まず、ユーザーディレクトリを定義して、サインアップ方法やパスワードポリシーを設定する。  
アプリクライアント側（認証を求めてくるクライアント）によって、推奨される認証フローが異なる点に注意

#### ユーザープールとアプリケーションの統合
Cognitoでは、OIDCの標準に準拠したエンドポイントが提供されている。
そのため、アプリへのリクエストに対して、Cognitoのエンドポイントにリダイレクトすることで認証・認可をCognitoに任せることができる。
Cognitoで認証してクライアント側にTokenを付与することで、Cognitoと連携するアプリへの一元的なアクセスができるようになる（シングルサインオン）

Cognitoへの認証を外部フェデレーテッドIDプロバイダと連携して任せることができる。
具体的なIDプロバイダとしてはGoogle ,Amazon ,Facebook ,Apple ,SAML, OpenIDConnectプロバイダが挙げられる。

### IDプール
ユーザープールや外部フェデレーションで認証したユーザーに対してAWSサービスを認可する機能を提供
1. ユーザープールで認証される
2. JWTがクライアントに提供される
3. クライアントがIDプールにTokenを渡す
4. IDプールがTokenの検証をする
5. Tokenが正しければ、STSに認証情報をもらう
6. クライアントが所望のサービスにアクセスする

### JWT
`署名付きの認証情報を含むToken`

署名がJWTの発行元の秘密鍵で暗号化されているため、公開鍵で復号化するだけで署名を検証することができる点が有用

ただし、期限付きの合鍵となるので奪取されることは避けなくてはいけないので取り扱いに注意が必要。
