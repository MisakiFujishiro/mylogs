# Lambda
サーバーのプロビジョニングや管理なしでプログラムを実行できるサービス

## Lambdaのメリット
コードの実行やスケーリングをLambada側で実施するので、開発者はコーディングに集中できる。

## Lambdaの詳細
### Lambda関数
Lambdaで実行するソースコードとそのソースコードを実行するランタイムを合わせてLambda関数と呼ぶ

### 環境設定
アプリケーションの実行に必要なライブラリやパッケージをランタイムとして設定する。

CPUは設定することができないが、メモリスペックを設定することができる。

### 同時実行数
Lambdaのある時点における実行している関数の数を`同時実行数`と呼ぶ。
同時実行数は以下の式で算出する。

> 同時実行=（1秒あたりの呼び出し数）x（平均実行時間（秒）） 


Lambdaはリージョンごとに最大同時実行数が決まっており、これを超える同時実行数を同時に捌きたい場合は別途申請が必要となる。
東京の最大同時実行数は1000であり、Lambdaではリクエストとコンテナ数が1対1となるので、1000以上のリクエストを同時に捌きたい場合は申請が必要となる。



### Lambda関数のライフサイクル
Lambdaの実態は、EC2(Amazon Linux)かDockerコンテナであり、以下の順序を踏んで実行される
1. コンテナ作成
2. デプロイパッケージのロード
3. デプロイパッケージの展開
4. ランタイム起動
5. 関数の実行
6. コンテナの破棄

#### ウォームスタート
Lambdaに継続的なリクエストが飛んできている場合、1-4のプロセスはスキップされて、5から処理される。

#### コールドスタート
コンテナが不要と判断されると破棄されてしまうので、1番からやり直しとなる。

#### Provisioned Concurrency
性能要件が厳しい場合は、事前にプロビジョニングしておくことが可能

### バージョン
Lambda関数はバージョニング機能があるが、バージョンとして公開されると編集することができない点に注意

### エイリアス
エイリアスとはLambda関数の別名であり、prd,stg,devなどを設定できる。
エイリアスは同名で２つまで付与することができるので、エイリアスでルーティングをするとカナリアリリースを実現することができる。

### Layers
複数のLambda関数が共通で利用するライブラリをZIPファイルで切り出して共有する機能
1つのLambda関数から最大5つのLayerを利用することができる。



### 一時ファイル
Lambdaは512MBの一時ファイルを`/tmp`として持つ。
注意が必要なのは、Lambdaが連続で起動している時に、tmpが共有されてしまうこと。

[Lambdaで/tmpディレクトリの利用](https://cloud5.jp/lambda_tmp_directory/)

### 署名付きURL
AWS SDKやCLIを利用することでSTSの機能によって一時的にS3へアクセス可能なURLを発行させることができる。


## Lambdaの呼び出しかた分類
Lambdaは呼び出し元のサービスによって、呼び出され方が異なる。

![](img/lambda_call.png)

４つの種別については、以下のような分類がある。

![](img/lambda_call_detail.png)
大きな分類手である、ポーリングとはLambdaがイベントを取りに行くのか、呼ばれるのかの分類である。

### ①Lambda関数を同期的に呼び出す
Lambdaを呼び出したら、その実行が完了するのを待つ。  
イベント元に実行結果を返す。

エラー発生時にはエラーがレスポンスされるので、CloudWatch Logsのサブスクリプションフィルタなどを利用する。  
※S3のイベント契機をSQSで受け取ってLambdaがポーリングする場合同期処理になる点に注意。

### ②Lambda関数を非同期的に呼び出す
イベント型のAWSサービスは非同期となる(S3/SNS/CloudWatch Events/EventBridge)

Lambdaを呼び出すと、一旦Lambda内のQueueに格納されてからLambdaが実行される。
イベントソースには、キューへの格納成功だけが返されるので、結果は返されない。

エラー時の挙動はリトライ設定があるが、呼び出し元に通知はいかないので、デッドレターキューなどを利用する。


![](img/lambda_call_ansync.png)

### ③Lambdaがイベントを読み取る(イベントソースマッピング)
Lambdaが新しいイベントがないがないかポーリングする。


### 呼び出し方に応じたエラーハンドリング
- 同期処理の場合（1-a）  
    結果をそのままレスポンスに埋め込んで返却するので、CloudWatchに流れていく。
    そのため、エラーに応じた通知などはLambdaをもう一つ作成して処理を作り込む必要がある。
- 非同期処理の場合(1-b)  
    イベントを受け付けると、Lambdaの処理中にエラーが発生しても2回リトライされる。
    処理が以上終了しても呼び出し元へ通知はされないがその代わりデッドレターキューをSNSやSQSで定義することができる。この情報を利用して、通知の設定することが可能。


![](img/lambda_errorhandling.png)


## LambdaとS3・AIなどのAWSサービスの連携
### H4b
[H4B：AWS LambdaとAWS AI Servicesを組み合わせて作る音声文字起こし&感情分析パイプライン](https://pages.awscloud.com/JAPAN-event-OE-Hands-on-for-Beginners-Serverless-3-2022-confirmation_772.html)
の内容を踏まえてLambadaの手順などを整理する。

#### 全体構成
S3に音声データをアップロードするとS3のイベントが発出され、Lambdaがそれを受け取る。  
LambdaがTranscribeを呼び出して、テキストデータに変換し、そのデータをS3にアップロードする。  
テキストのアップロードを契機として、再度Lambdaを呼び出して、ポジネガ判定を行う。

- Polly:テキストから音声を生成するAIサービス
- Transcribe:音声からテキストを生成するAIサービス
- comprehend:文章のポジネガ判定を行うAIサービス


![](img/lambda_archie.png)

#### S3とLambdaの連携
[S3の手順書](./S3.md)に記載
S3バケットの作成をして、Lambdaからpython-get-s3-objectからコードを作成する。


#### LambdaとTranscribeの連携
Transcribeの基本的使い方は[AIのメモ](./AI.md)を確認。
S3内部の音声データのObjectを指定すると、文字起こしをして指定したs3のディレクトリにjsonファイルを吐き出す。

LambdaのIAM Roleについて、TranscribeやS3への権限を付与する
- transcribeFullAccess
- S3FullAccess

Lambdaの関数の中身を変更する。LambdaからAWSを呼び出すときは[リファレンス](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/transcribe.html)を参考にする  
処理の中身はs3からデータを受け取って、Transcribeに連携、Transcribeの保存先にS3を指定
```
import json
import urllib.parse
import boto3
import datetime # jobuをユニークにするため

# s3のclient作成
s3 = boto3.client('s3')
# transcribeのclient作成
transcribe = boto3.client('transcribe')


def lambda_handler(event, context):
    # bucket名取得
    bucket = event['Records'][0]['s3']['bucket']['name']
    # object名取得
    key = urllib.parse.unquote_plus(event['Records'][0]['s3']['object']['key'], encoding='utf-8')
    
    try:
         transcribe.start_transcription_job(
            # job名をユニークに設定
            TranscriptionJobName= datetime.datetime.now().strftime('%Y%m%d%H%M%S') + '_Transcription',
            # 日本語を対象に設定
            LanguageCode='ja-JP',
            Media={
                # 入力メディアのパス
                'MediaFileUri': 'https://s3.ap-northeast-1.amazon.com/' + bucket + '/' + key
             },
            # 出力するs3バケットの情報[s3::]は不要
            OutputBucketName='bucket-h4b-serverless-output',
            # 出力するs3バケット内のディレクトリ
            OutputKey = 'transcribe-output/'
        )    
    except Exception as e:
        print(e)
        print('Error getting object {} from bucket {}. Make sure they exist and your bucket is in the same region as this function.'.format(key, bucket))
        raise e

```
Lambdaファンクションを修正したら、Deployを忘れずに！


#### S3への連携
TranscribeがS3に格納したイベントを契機にして、Comprehendにデータを渡す。  
Transcribeの基本的使い方は[AIのメモ](./AI.md)を確認。


1. Lambdaの作成  
前回同様に、S3へのファイルアップロードを契機とする。  
アップロードされたjsonファイル飲みを対象とするので、Suffixで指定

![](img/lambda_comprehend.png)

2. IAMロールの修正
    - S3FullAccess
    - ComprehendFullAccess
   
3. Lambdaの修正  
今回は感情分析の`detect_sentiment`関数を利用する。
関数の設定方法は[リファレンス](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/comprehend.html#Comprehend.Client.detect_sentiment)参照  


```
import json
import urllib.parse
import boto3

s3 = boto3.client('s3')
# comprehendのクライアントを設定
comprehend = boto3.client('comprehend')

def lambda_handler(event, context):
    # bucket名を取得
    bucket = event['Records'][0]['s3']['bucket']['name']
    # object名を取得
    key = urllib.parse.unquote_plus(event['Records'][0]['s3']['object']['key'], encoding='utf-8')
    try:
        # objectの中身を取得
        response = s3.get_object(Bucket=bucket, Key=key)
        
        # jsonに変換
        body = json.load(response['Body'])
        # 中身からテキストを抽出
        comprehend_text = body['results']['transcripts'][0]['transcript']
        
        # 感情分析のAPI呼び出し
        sentiment_response = comprehend.detect_sentiment(
            Text=comprehend_text,
            LanguageCode='ja'
        )
        
        # 感情分析の結果からスコアを取得
        sentiment_score = sentiment_response['SentimentScore']
        # CloudWatchで確認できるようにprint
        print(sentiment_score)
        
        
    except Exception as e:
        print(e)
        print('Error getting object {} from bucket {}. Make sure they exist and your bucket is in the same region as this function.'.format(key, bucket))
        raise e

```
